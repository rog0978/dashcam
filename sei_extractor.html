<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>Dashcam SEI Extractor</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
        :root {
            color-scheme: light dark;
            --bg-color: #ffffff;
            --text-color: #1a1a1a;
            --text-muted: #666666;
            --link-color: #0080ff;
            --border-color: #888888;
            --dropzone-hover-bg: rgba(0, 128, 255, 0.08);
            --dropzone-hover-border: #0080ff;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg-color: #1a1a1a;
                --text-color: #e8e8e8;
                --text-muted: #999999;
                --link-color: #4da6ff;
                --border-color: #666666;
                --dropzone-hover-bg: rgba(77, 166, 255, 0.12);
                --dropzone-hover-border: #4da6ff;
            }
        }

        body {
            font-family: system-ui, -apple-system, sans-serif;
            line-height: 1.5;
            max-width: 600px;
            margin: 0 auto;
            padding: 1.5rem 1rem;
            background-color: var(--bg-color);
            color: var(--text-color);
        }

        @media (min-width: 640px) {
            body {
                padding: 2rem 1rem;
            }
        }

        h1 {
            margin-bottom: 0.25rem;
            font-size: clamp(1.5rem, 5vw, 2rem);
        }

        .subtitle {
            color: var(--text-muted);
            margin-top: 0;
        }

        a {
            color: var(--link-color);
        }

        ul {
            padding-left: 1.25rem;
        }

        .note {
            font-size: 0.9rem;
            color: var(--text-muted);
        }

        label {
            font-weight: 600;
        }

        #file-input {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        #drop-zone {
            margin-top: 1.5rem;
            padding: 1.5rem 1rem;
            border: 2px dashed var(--border-color);
            border-radius: 8px;
            text-align: center;
            transition: background-color 0.2s ease, border-color 0.2s ease;
            cursor: pointer;
        }

        @media (min-width: 640px) {
            #drop-zone {
                padding: 2rem;
            }
        }

        #drop-zone.dragover {
            background-color: var(--dropzone-hover-bg);
            border-color: var(--dropzone-hover-border);
        }

        #status {
            margin-top: 1.25rem;
            font-size: 0.95rem;
        }

        .nav {
            margin-bottom: 1rem;
            font-size: 0.9rem;
        }
    </style>
</head>

<body>
    <p class="nav"><a href="index.html">← Back to Dashcam Tools</a></p>
    <h1>Tesla Dashcam SEI Extractor</h1>
    <p class="subtitle">Web-based metadata extractor. Generates a CSV of the metadata from an MP4.</p>

    <p>Select one or more Tesla dashcam MP4 files to extract their SEI metadata into CSV. Works entirely in your browser
        — your files never leave your computer.</p>

    <input id="file-input" type="file" accept="video/mp4" multiple />
    <div id="drop-zone">Click or drop MP4 files here</div>
    <div id="status"></div>

    <p class="note">Not all Tesla-generated dashcam clips contain SEI data. Only clips recorded on Tesla firmware
        2025.44.25 or later and HW3 or above contain SEI data. If car is parked, SEI data may not be present.</p>

    <p class="note">
        <a href="https://github.com/teslamotors/dashcam/blob/master/sei_extractor.py">
            View on GitHub
        </a>
    </p>

    <script src="vendor/protobuf.min.js"></script>
    <script src="vendor/jszip.min.js"></script>
    <script src="dashcam-mp4.js"></script>
    <script src="dashcam-helpers.js"></script>
    <script>
        const FILE_REQUIREMENT = 'No SEI metadata found. Requires dashcam footage recorded on Tesla firmware 2025.44.25 or later and HW3 or above. If car is parked, SEI data may not be present.';

        let seiType = null, seiFields = null;

        // Initialize protobuf
        DashcamHelpers.initProtobuf().then(({ SeiMetadata, enumFields }) => {
            seiType = SeiMetadata;
            seiFields = DashcamHelpers.deriveFieldInfo(SeiMetadata, enumFields, { useSnakeCase: true });
        }).catch(err => console.error('Protobuf init failed:', err));

        const fileInput = document.getElementById('file-input');
        const dropZone = document.getElementById('drop-zone');
        const statusEl = document.getElementById('status');

        fileInput.addEventListener('change', e => { handleFiles(e.target.files); e.target.value = ''; });
        dropZone.addEventListener('click', () => fileInput.click());
        document.ondragover = e => { e.preventDefault(); dropZone.classList.add('dragover'); };
        document.ondragleave = e => { if (!e.relatedTarget) dropZone.classList.remove('dragover'); };
        document.ondrop = async e => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            const items = e.dataTransfer?.items;
            if (items) {
                const { files, directoryName } = await getFilesFromDataTransfer(items);
                handleFiles(files, directoryName);
            } else {
                handleFiles(e.dataTransfer?.files ?? []);
            }
        };

        async function getFilesFromDataTransfer(items) {
            const files = [], entries = [];
            let directoryName = null;
            for (const item of items) {
                const entry = item.webkitGetAsEntry?.();
                if (entry) {
                    entries.push(entry);
                    if (entry.isDirectory && entries.length === 1) directoryName = entry.name;
                }
            }
            if (entries.length !== 1 || !entries[0].isDirectory) directoryName = null;
            await Promise.all(entries.map(e => traverseEntry(e, files)));
            return { files, directoryName };
        }

        async function traverseEntry(entry, files) {
            if (entry.isFile) {
                const file = await new Promise((res, rej) => entry.file(res, rej));
                if (file.name.toLowerCase().endsWith('.mp4')) files.push(file);
            } else if (entry.isDirectory) {
                const reader = entry.createReader();
                const entries = await new Promise((res, rej) => reader.readEntries(res, rej));
                await Promise.all(entries.map(e => traverseEntry(e, files)));
            }
        }

        async function handleFiles(fileList, directoryName = null) {
            if (!seiType) await DashcamHelpers.initProtobuf().then(({ SeiMetadata, enumFields }) => {
                seiType = SeiMetadata;
                seiFields = DashcamHelpers.deriveFieldInfo(SeiMetadata, enumFields, { useSnakeCase: true });
            });

            const files = (Array.isArray(fileList) ? fileList : Array.from(fileList))
                .filter(f => f.name.toLowerCase().endsWith('.mp4'));
            if (!files.length) { statusEl.textContent = 'Please choose at least one MP4 file.'; return; }

            statusEl.textContent = `Processing ${files.length} file${files.length === 1 ? '' : 's'}…`;
            const successes = [], failures = [];

            for (const file of files) {
                try {
                    successes.push(await processFile(file));
                } catch (error) {
                    failures.push({ file, error });
                    if (files.length === 1 && error?.code === 'NO_SEI') alert(FILE_REQUIREMENT);
                }
            }

            if (!successes.length) { statusEl.textContent = failures.length ? 'No files produced SEI metadata.' : 'Nothing to do.'; return; }

            if (successes.length === 1) {
                downloadBlob(new Blob([successes[0].csv], { type: 'text/csv' }), successes[0].filename);
            } else {
                const zip = new JSZip();
                for (const { filename, csv } of successes) zip.file(filename, csv);
                downloadBlob(await zip.generateAsync({ type: 'blob' }), directoryName ? `${directoryName}_sei.zip` : 'dashcam_sei_metadata.zip');
            }

            const summary = successes.length === 1
                ? `Extracted ${successes[0].rows} row${successes[0].rows === 1 ? '' : 's'} from ${successes[0].source}.`
                : `Exported ${successes.length} CSVs as ZIP.`;
            statusEl.textContent = `${summary} ${failures.length ? `${failures.length} file${failures.length === 1 ? '' : 's'} skipped.` : ''}`.trim();
        }

        async function processFile(file) {
            const mp4 = new DashcamMP4(await file.arrayBuffer());
            const messages = mp4.extractSeiMessages(seiType);
            if (!messages.length) { const err = new Error(FILE_REQUIREMENT); err.code = 'NO_SEI'; throw err; }
            return {
                filename: file.name.replace(/\.mp4$/i, '') + '_sei.csv',
                csv: DashcamHelpers.buildCsv(messages, seiFields),
                rows: messages.length,
                source: file.name
            };
        }

        function downloadBlob(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = Object.assign(document.createElement('a'), { href: url, download: filename });
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            setTimeout(() => URL.revokeObjectURL(url), 1000);
        }
    </script>
</body>

</html>